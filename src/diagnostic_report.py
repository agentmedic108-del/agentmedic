"""
AgentMedic Diagnostic Report Generator
======================================
Generates comprehensive diagnostic reports combining:
- Agent health status
- SolanaScope anomaly detection
- Historical pattern analysis
- Memory persistence data
- Recovery recommendations

This is the main output of AgentMedic - a complete picture of agent health.
"""

import json
import asyncio
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List
from dataclasses import dataclass, asdict
from enum import Enum

# Import other AgentMedic modules
try:
    from solanascope_integration import diagnose_counterparty, check_price_reliability
    SOLANASCOPE_AVAILABLE = True
except ImportError:
    SOLANASCOPE_AVAILABLE = False

try:
    from memory_persistence import MemoryPersistence, StorageBackend
    MEMORY_AVAILABLE = True
except ImportError:
    MEMORY_AVAILABLE = False


class HealthStatus(Enum):
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    UNKNOWN = "unknown"


class IncidentSeverity(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class AgentHealthCheck:
    """Result of checking an agent's health."""
    agent_id: str
    timestamp: str
    status: HealthStatus
    checks: Dict[str, Any]
    issues: List[str]
    
    def to_dict(self) -> Dict:
        result = asdict(self)
        result['status'] = self.status.value
        return result


@dataclass
class DiagnosticReport:
    """Complete diagnostic report for an agent incident."""
    report_id: str
    agent_id: str
    timestamp: str
    incident_type: str
    severity: IncidentSeverity
    
    # Health data
    health_check: Optional[AgentHealthCheck]
    
    # External data
    wallet_analysis: Optional[Dict[str, Any]]
    price_reliability: Optional[Dict[str, Any]]
    
    # Analysis
    root_cause: str
    contributing_factors: List[str]
    
    # Recommendations
    immediate_actions: List[str]
    preventive_measures: List[str]
    
    # Metadata
    data_sources: List[str]
    confidence_score: float  # 0-1
    
    def to_dict(self) -> Dict:
        result = asdict(self)
        result['severity'] = self.severity.value
        if self.health_check:
            result['health_check'] = self.health_check.to_dict()
        return result
    
    def to_json(self, indent: int = 2) -> str:
        return json.dumps(self.to_dict(), indent=indent)
    
    def to_markdown(self) -> str:
        """Generate a human-readable markdown report."""
        md = f"""# AgentMedic Diagnostic Report

**Report ID:** {self.report_id}  
**Agent:** {self.agent_id}  
**Generated:** {self.timestamp}  
**Severity:** {self.severity.value.upper()}

---

## Incident Summary

**Type:** {self.incident_type}  
**Root Cause:** {self.root_cause}

### Contributing Factors
"""
        for factor in self.contributing_factors:
            md += f"- {factor}\n"
        
        md += "\n---\n\n## Health Check\n\n"
        if self.health_check:
            md += f"**Status:** {self.health_check.status.value.upper()}\n\n"
            md += "| Check | Result |\n|-------|--------|\n"
            for check, result in self.health_check.checks.items():
                md += f"| {check} | {result} |\n"
            
            if self.health_check.issues:
                md += "\n**Issues Found:**\n"
                for issue in self.health_check.issues:
                    md += f"- âš ï¸ {issue}\n"
        else:
            md += "*Health check data not available*\n"
        
        if self.wallet_analysis:
            md += f"\n---\n\n## Wallet Analysis (via SolanaScope)\n\n"
            md += f"**Risk Level:** {self.wallet_analysis.get('risk_level', 'unknown')}\n"
            md += f"**Recommendation:** {self.wallet_analysis.get('recommendation', 'N/A')}\n"
        
        if self.price_reliability:
            md += f"\n---\n\n## Price Data Analysis\n\n"
            md += f"**Reliable:** {'Yes' if self.price_reliability.get('reliable') else 'No'}\n"
            md += f"**Confidence:** {self.price_reliability.get('confidence_pct', 'N/A')}\n"
        
        md += "\n---\n\n## Recommendations\n\n"
        md += "### Immediate Actions\n"
        for i, action in enumerate(self.immediate_actions, 1):
            md += f"{i}. {action}\n"
        
        md += "\n### Preventive Measures\n"
        for measure in self.preventive_measures:
            md += f"- {measure}\n"
        
        md += f"\n---\n\n**Data Sources:** {', '.join(self.data_sources)}  \n"
        md += f"**Confidence Score:** {self.confidence_score:.0%}\n"
        md += "\n*Generated by AgentMedic ðŸ¥*\n"
        
        return md


class DiagnosticEngine:
    """
    Main diagnostic engine for AgentMedic.
    Combines multiple data sources to generate comprehensive reports.
    """
    
    def __init__(self, agent_id: str = "AgentMedic"):
        self.agent_id = agent_id
        self.report_counter = 0
    
    def _generate_report_id(self) -> str:
        self.report_counter += 1
        date = datetime.now(timezone.utc).strftime("%Y%m%d")
        return f"DIAG-{date}-{self.report_counter:04d}"
    
    async def check_agent_health(self, agent_id: str, process_name: Optional[str] = None) -> AgentHealthCheck:
        """Perform basic health checks on an agent."""
        checks = {}
        issues = []
        
        # Check 1: Process running (simulated)
        checks["process_running"] = process_name is None or True  # Would check actual process
        if not checks["process_running"]:
            issues.append(f"Process '{process_name}' is not running")
        
        # Check 2: Memory usage (simulated)
        checks["memory_ok"] = True
        checks["memory_usage"] = "45%"
        
        # Check 3: Last activity (simulated)
        checks["recent_activity"] = True
        checks["last_heartbeat"] = "2 minutes ago"
        
        # Check 4: Error rate (simulated)
        checks["error_rate"] = "2%"
        checks["error_rate_ok"] = True
        
        # Determine overall status
        if not checks["process_running"]:
            status = HealthStatus.CRITICAL
        elif issues:
            status = HealthStatus.WARNING
        else:
            status = HealthStatus.HEALTHY
        
        return AgentHealthCheck(
            agent_id=agent_id,
            timestamp=datetime.now(timezone.utc).isoformat(),
            status=status,
            checks=checks,
            issues=issues
        )
    
    async def diagnose_incident(
        self,
        agent_id: str,
        incident_type: str,
        wallet_address: Optional[str] = None,
        check_prices: bool = False,
        context: Optional[Dict[str, Any]] = None
    ) -> DiagnosticReport:
        """
        Generate a comprehensive diagnostic report for an incident.
        
        Args:
            agent_id: ID of the affected agent
            incident_type: Type of incident (e.g., "transaction_failed", "process_crashed")
            wallet_address: Optional wallet to analyze
            check_prices: Whether to check price reliability
            context: Additional context about the incident
        """
        data_sources = ["agent_health_check"]
        
        # Health check
        health = await self.check_agent_health(agent_id)
        
        # Wallet analysis via SolanaScope
        wallet_analysis = None
        if wallet_address and SOLANASCOPE_AVAILABLE:
            try:
                wallet_analysis = await diagnose_counterparty(wallet_address)
                data_sources.append("solanascope_anomaly")
            except Exception as e:
                wallet_analysis = {"error": str(e)}
        
        # Price reliability check
        price_data = None
        if check_prices and SOLANASCOPE_AVAILABLE:
            try:
                price_data = await check_price_reliability("SOL/USD")
                data_sources.append("solanascope_prices")
            except Exception as e:
                price_data = {"error": str(e)}
        
        # Analyze and determine root cause
        root_cause, factors, severity = self._analyze_incident(
            incident_type, health, wallet_analysis, price_data, context
        )
        
        # Generate recommendations
        immediate, preventive = self._generate_recommendations(
            incident_type, root_cause, factors, severity
        )
        
        # Calculate confidence score
        confidence = self._calculate_confidence(data_sources, health, wallet_analysis)
        
        return DiagnosticReport(
            report_id=self._generate_report_id(),
            agent_id=agent_id,
            timestamp=datetime.now(timezone.utc).isoformat(),
            incident_type=incident_type,
            severity=severity,
            health_check=health,
            wallet_analysis=wallet_analysis,
            price_reliability=price_data,
            root_cause=root_cause,
            contributing_factors=factors,
            immediate_actions=immediate,
            preventive_measures=preventive,
            data_sources=data_sources,
            confidence_score=confidence
        )
    
    def _analyze_incident(
        self,
        incident_type: str,
        health: AgentHealthCheck,
        wallet: Optional[Dict],
        prices: Optional[Dict],
        context: Optional[Dict]
    ) -> tuple:
        """Analyze incident data to determine root cause."""
        factors = []
        
        # Default analysis
        root_cause = "Unable to determine root cause"
        severity = IncidentSeverity.MEDIUM
        
        if incident_type == "transaction_failed":
            if wallet and wallet.get("risk_level") in ["high", "critical"]:
                root_cause = "Transaction with suspicious counterparty wallet"
                factors.append(f"Wallet risk level: {wallet.get('risk_level')}")
                severity = IncidentSeverity.HIGH
            elif prices and not prices.get("reliable"):
                root_cause = "Unreliable price data during transaction"
                factors.append(f"Price confidence: {prices.get('confidence_pct')}")
                severity = IncidentSeverity.MEDIUM
            else:
                root_cause = "Transaction execution error"
                factors.append("Check transaction parameters")
        
        elif incident_type == "process_crashed":
            if health.status == HealthStatus.CRITICAL:
                root_cause = "Agent process terminated unexpectedly"
                severity = IncidentSeverity.CRITICAL
                factors.extend(health.issues)
            else:
                root_cause = "Process crash - cause unknown"
                severity = IncidentSeverity.HIGH
        
        elif incident_type == "rpc_timeout":
            root_cause = "Solana RPC endpoint unresponsive"
            factors.append("Network congestion or RPC overload")
            severity = IncidentSeverity.MEDIUM
        
        elif incident_type == "rate_limited":
            root_cause = "API rate limit exceeded"
            factors.append("Too many requests in short period")
            severity = IncidentSeverity.LOW
        
        # Add health issues as factors
        if health.issues:
            factors.extend(health.issues)
        
        return root_cause, factors, severity
    
    def _generate_recommendations(
        self,
        incident_type: str,
        root_cause: str,
        factors: List[str],
        severity: IncidentSeverity
    ) -> tuple:
        """Generate actionable recommendations."""
        immediate = []
        preventive = []
        
        if incident_type == "transaction_failed":
            immediate = [
                "Review transaction parameters",
                "Check wallet balances",
                "Verify counterparty address"
            ]
            preventive = [
                "Implement pre-transaction validation",
                "Add counterparty reputation checks",
                "Set up transaction simulation before execution"
            ]
        
        elif incident_type == "process_crashed":
            immediate = [
                "Restart agent with backoff",
                "Check system resources (memory, CPU)",
                "Review recent logs for errors"
            ]
            preventive = [
                "Implement graceful shutdown handlers",
                "Add memory usage monitoring",
                "Set up automatic restart on crash"
            ]
        
        elif incident_type == "rpc_timeout":
            immediate = [
                "Switch to backup RPC endpoint",
                "Retry with exponential backoff"
            ]
            preventive = [
                "Configure multiple RPC endpoints",
                "Implement RPC health monitoring",
                "Add request timeout handling"
            ]
        
        elif incident_type == "rate_limited":
            immediate = [
                "Wait for rate limit reset",
                "Reduce request frequency"
            ]
            preventive = [
                "Implement request queuing",
                "Add rate limit tracking",
                "Use multiple API keys if available"
            ]
        
        # Add severity-specific recommendations
        if severity == IncidentSeverity.CRITICAL:
            immediate.insert(0, "âš ï¸ CRITICAL: Escalate to human operator")
        
        return immediate, preventive
    
    def _calculate_confidence(
        self,
        data_sources: List[str],
        health: AgentHealthCheck,
        wallet: Optional[Dict]
    ) -> float:
        """Calculate confidence score based on available data."""
        score = 0.5  # Base score
        
        # More data sources = higher confidence
        score += len(data_sources) * 0.1
        
        # Successful health check
        if health and health.status != HealthStatus.UNKNOWN:
            score += 0.15
        
        # External data available
        if wallet and wallet.get("checked"):
            score += 0.15
        
        return min(score, 1.0)


async def demo():
    """Demonstrate the diagnostic report generator."""
    print("=" * 60)
    print("AgentMedic Diagnostic Report Generator Demo")
    print("=" * 60)
    
    engine = DiagnosticEngine()
    
    # Simulate a transaction failure
    print("\n[Simulating transaction failure incident...]\n")
    
    report = await engine.diagnose_incident(
        agent_id="TradingBot-Alpha",
        incident_type="transaction_failed",
        wallet_address="DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK",
        check_prices=True
    )
    
    # Output markdown report
    print(report.to_markdown())
    
    # Also save JSON
    print("\n[JSON Report]")
    print(report.to_json())


if __name__ == "__main__":
    asyncio.run(demo())
